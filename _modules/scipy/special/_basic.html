<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scipy.special._basic &#8212; stingray v1.1.2.dev118+gd47d50d</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bootstrap-astropy.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css" />
    
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../_static/stingray_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">Sting</span><span id="logotext2">ray</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">stingray v1.1.2.dev118+gd47d50d</a>
	 &#187;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for scipy.special._basic</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Author:  Travis Oliphant, 2002</span>
<span class="c1">#</span>

<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">isscalar</span><span class="p">,</span> <span class="n">iscomplex</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span>
                   <span class="n">imag</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">mgrid</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">place</span><span class="p">,</span> <span class="n">issubdtype</span><span class="p">,</span>
                   <span class="n">extract</span><span class="p">,</span> <span class="n">inexact</span><span class="p">,</span> <span class="n">nan</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">sinc</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_ufuncs</span>
<span class="kn">from</span> <span class="nn">._ufuncs</span> <span class="kn">import</span> <span class="p">(</span><span class="n">mathieu_a</span><span class="p">,</span> <span class="n">mathieu_b</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">jv</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span>
                      <span class="n">psi</span><span class="p">,</span> <span class="n">hankel1</span><span class="p">,</span> <span class="n">hankel2</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">kv</span><span class="p">,</span> <span class="n">poch</span><span class="p">,</span> <span class="n">binom</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_specfun</span>
<span class="kn">from</span> <span class="nn">._comb</span> <span class="kn">import</span> <span class="n">_comb_int</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;ai_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assoc_laguerre&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bei_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;beip_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ber_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bernoulli&#39;</span><span class="p">,</span>
    <span class="s1">&#39;berp_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bi_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;clpmn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;comb&#39;</span><span class="p">,</span>
    <span class="s1">&#39;digamma&#39;</span><span class="p">,</span>
    <span class="s1">&#39;diric&#39;</span><span class="p">,</span>
    <span class="s1">&#39;erf_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;euler&#39;</span><span class="p">,</span>
    <span class="s1">&#39;factorial&#39;</span><span class="p">,</span>
    <span class="s1">&#39;factorial2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;factorialk&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fresnel_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fresnelc_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fresnels_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;h1vp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;h2vp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ivp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jn_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jnjnp_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jnp_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jnyn_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jvp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;kei_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;keip_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;kelvin_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ker_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;kerp_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;kvp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lmbda&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lpmn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lpn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lqmn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lqn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mathieu_even_coef&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mathieu_odd_coef&#39;</span><span class="p">,</span>
    <span class="s1">&#39;obl_cv_seq&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pbdn_seq&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pbdv_seq&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pbvv_seq&#39;</span><span class="p">,</span>
    <span class="s1">&#39;perm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;polygamma&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pro_cv_seq&#39;</span><span class="p">,</span>
    <span class="s1">&#39;riccati_jn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;riccati_yn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sinc&#39;</span><span class="p">,</span>
    <span class="s1">&#39;y0_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;y1_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;y1p_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;yn_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ynp_zeros&#39;</span><span class="p">,</span>
    <span class="s1">&#39;yvp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;zeta&#39;</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="c1"># Raises an exception if float</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">err</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> must be a non-negative integer&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var_name</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">err</span>
    <span class="k">return</span> <span class="n">n</span>


<span class="k">def</span> <span class="nf">diric</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Periodic sinc function, also called the Dirichlet function.</span>

<span class="sd">    The Dirichlet function is defined as::</span>

<span class="sd">        diric(x, n) = sin(x * n/2) / (n * sin(x / 2)),</span>

<span class="sd">    where `n` is a positive integer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Input data</span>
<span class="sd">    n : int</span>
<span class="sd">        Integer defining the periodicity.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diric : ndarray</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(-8*np.pi, 8*np.pi, num=201)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(8, 8));</span>
<span class="sd">    &gt;&gt;&gt; for idx, n in enumerate([2, 3, 4, 9]):</span>
<span class="sd">    ...     plt.subplot(2, 2, idx+1)</span>
<span class="sd">    ...     plt.plot(x, special.diric(x, n))</span>
<span class="sd">    ...     plt.title(&#39;diric, n={}&#39;.format(n))</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    The following example demonstrates that `diric` gives the magnitudes</span>
<span class="sd">    (modulo the sign and scaling) of the Fourier coefficients of a</span>
<span class="sd">    rectangular pulse.</span>

<span class="sd">    Suppress output of values that are effectively 0:</span>

<span class="sd">    &gt;&gt;&gt; np.set_printoptions(suppress=True)</span>

<span class="sd">    Create a signal `x` of length `m` with `k` ones:</span>

<span class="sd">    &gt;&gt;&gt; m = 8</span>
<span class="sd">    &gt;&gt;&gt; k = 3</span>
<span class="sd">    &gt;&gt;&gt; x = np.zeros(m)</span>
<span class="sd">    &gt;&gt;&gt; x[:k] = 1</span>

<span class="sd">    Use the FFT to compute the Fourier transform of `x`, and</span>
<span class="sd">    inspect the magnitudes of the coefficients:</span>

<span class="sd">    &gt;&gt;&gt; np.abs(np.fft.fft(x))</span>
<span class="sd">    array([ 3.        ,  2.41421356,  1.        ,  0.41421356,  1.        ,</span>
<span class="sd">            0.41421356,  1.        ,  2.41421356])</span>

<span class="sd">    Now find the same values (up to sign) using `diric`. We multiply</span>
<span class="sd">    by `k` to account for the different scaling conventions of</span>
<span class="sd">    `numpy.fft.fft` and `diric`:</span>

<span class="sd">    &gt;&gt;&gt; theta = np.linspace(0, 2*np.pi, m, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; k * special.diric(theta, k)</span>
<span class="sd">    array([ 3.        ,  2.41421356,  1.        , -0.41421356, -1.        ,</span>
<span class="sd">           -0.41421356,  1.        ,  2.41421356])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">n</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">):</span>
        <span class="n">ytype</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ytype</span> <span class="o">=</span> <span class="nb">float</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ytype</span><span class="p">)</span>

    <span class="c1"># empirical minval for 32, 64 or 128 bit float computations</span>
    <span class="c1"># where sin(x/2) &lt; minval, result is fixed at +1 or -1</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">ytype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">&lt;</span> <span class="mf">1e-18</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="mf">1e-11</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">ytype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">&lt;</span> <span class="mf">1e-15</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="mf">1e-7</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="mf">1e-3</span>

    <span class="n">mask1</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask1</span><span class="p">,</span> <span class="n">nan</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">mask2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">mask1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minval</span><span class="p">)</span>
    <span class="n">xsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">nsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">zsub</span> <span class="o">=</span> <span class="n">xsub</span> <span class="o">/</span> <span class="n">pi</span>
    <span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask2</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">zsub</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">nsub</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">mask1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">mask2</span><span class="p">)</span>
    <span class="n">xsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">nsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">dsub</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>
    <span class="n">place</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">nsub</span><span class="o">*</span><span class="n">xsub</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nsub</span><span class="o">*</span><span class="n">dsub</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">jnjnp_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel functions Jn and Jn&#39;.</span>

<span class="sd">    Results are arranged in order of the magnitudes of the zeros.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number (&lt;=1200) of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zo[l-1] : ndarray</span>
<span class="sd">        Value of the lth zero of Jn(x) and Jn&#39;(x). Of length `nt`.</span>
<span class="sd">    n[l-1] : ndarray</span>
<span class="sd">        Order of the Jn(x) or Jn&#39;(x) associated with lth zero. Of length `nt`.</span>
<span class="sd">    m[l-1] : ndarray</span>
<span class="sd">        Serial number of the zeros of Jn(x) or Jn&#39;(x) associated</span>
<span class="sd">        with lth zero. Of length `nt`.</span>
<span class="sd">    t[l-1] : ndarray</span>
<span class="sd">        0 if lth zero in zo is zero of Jn(x), 1 if it is a zero of Jn&#39;(x). Of</span>
<span class="sd">        length `nt`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    jn_zeros, jnp_zeros : to get separated arrays of zeros.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1200</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number must be integer &lt;= 1200.&quot;</span><span class="p">)</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">zo</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">jdzo</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">zo</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nt</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">[:</span><span class="n">nt</span><span class="p">],</span> <span class="n">m</span><span class="p">[:</span><span class="n">nt</span><span class="p">],</span> <span class="n">t</span><span class="p">[:</span><span class="n">nt</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel functions Jn(x), Jn&#39;(x), Yn(x), and Yn&#39;(x).</span>

<span class="sd">    Returns 4 arrays of length `nt`, corresponding to the first `nt`</span>
<span class="sd">    zeros of Jn(x), Jn&#39;(x), Yn(x), and Yn&#39;(x), respectively. The zeros</span>
<span class="sd">    are returned in ascending order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of the Bessel functions</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number (&lt;=1200) of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Jn : ndarray</span>
<span class="sd">        First `nt` zeros of Jn</span>
<span class="sd">    Jnp : ndarray</span>
<span class="sd">        First `nt` zeros of Jn&#39;</span>
<span class="sd">    Yn : ndarray</span>
<span class="sd">        First `nt` zeros of Yn</span>
<span class="sd">    Ynp : ndarray</span>
<span class="sd">        First `nt` zeros of Yn&#39;</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    jn_zeros, jnp_zeros, yn_zeros, ynp_zeros</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the first three roots of :math:`J_1`, :math:`J_1&#39;`,</span>
<span class="sd">    :math:`Y_1` and :math:`Y_1&#39;`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import jnyn_zeros</span>
<span class="sd">    &gt;&gt;&gt; jn_roots, jnp_roots, yn_roots, ynp_roots = jnyn_zeros(1, 3)</span>
<span class="sd">    &gt;&gt;&gt; jn_roots, yn_roots</span>
<span class="sd">    (array([ 3.83170597,  7.01558667, 10.17346814]),</span>
<span class="sd">     array([2.19714133, 5.42968104, 8.59600587]))</span>

<span class="sd">    Plot :math:`J_1`, :math:`J_1&#39;`, :math:`Y_1`, :math:`Y_1&#39;` and their roots.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import jnyn_zeros, jvp, jn, yvp, yn</span>
<span class="sd">    &gt;&gt;&gt; jn_roots, jnp_roots, yn_roots, ynp_roots = jnyn_zeros(1, 3)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; xmax= 11</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, xmax)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, jn(1, x), label=r&quot;$J_1$&quot;, c=&#39;r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, jvp(1, x, 1), label=r&quot;$J_1&#39;$&quot;, c=&#39;b&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, yn(1, x), label=r&quot;$Y_1$&quot;, c=&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 1), label=r&quot;$Y_1&#39;$&quot;, c=&#39;c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; zeros = np.zeros((3, ))</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(jn_roots, zeros, s=30, c=&#39;r&#39;, zorder=5,</span>
<span class="sd">    ...            label=r&quot;$J_1$ roots&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(jnp_roots, zeros, s=30, c=&#39;b&#39;, zorder=5,</span>
<span class="sd">    ...            label=r&quot;$J_1&#39;$ roots&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(yn_roots, zeros, s=30, c=&#39;y&#39;, zorder=5,</span>
<span class="sd">    ...            label=r&quot;$Y_1$ roots&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(ynp_roots, zeros, s=30, c=&#39;c&#39;, zorder=5,</span>
<span class="sd">    ...            label=r&quot;$Y_1&#39;$ roots&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.hlines(0, 0, xmax, color=&#39;k&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-0.6, 0.6)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_xlim(0, xmax)</span>
<span class="sd">    &gt;&gt;&gt; ax.legend(ncol=2, bbox_to_anchor=(1., 0.75))</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be integers.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt &gt; 0&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">jyzo</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">jn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel functions Jn.</span>

<span class="sd">    Compute `nt` zeros of the Bessel functions :math:`J_n(x)` on the</span>
<span class="sd">    interval :math:`(0, \infty)`. The zeros are returned in ascending</span>
<span class="sd">    order. Note that this interval excludes the zero at :math:`x = 0`</span>
<span class="sd">    that exists for :math:`n &gt; 0`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Bessel function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    jv: Real-order Bessel functions of the first kind</span>
<span class="sd">    jnp_zeros: Zeros of :math:`Jn&#39;`</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the first four positive roots of :math:`J_3`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import jn_zeros</span>
<span class="sd">    &gt;&gt;&gt; jn_zeros(3, 4)</span>
<span class="sd">    array([ 6.3801619 ,  9.76102313, 13.01520072, 16.22346616])</span>

<span class="sd">    Plot :math:`J_3` and its first four positive roots. Note</span>
<span class="sd">    that the root located at 0 is not returned by `jn_zeros`.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import jn, jn_zeros</span>
<span class="sd">    &gt;&gt;&gt; j3_roots = jn_zeros(3, 4)</span>
<span class="sd">    &gt;&gt;&gt; xmax = 18</span>
<span class="sd">    &gt;&gt;&gt; xmin = -1</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(xmin, xmax, 500)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, jn(3, x), label=r&#39;$J_3$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(j3_roots, np.zeros((4, )), s=30, c=&#39;r&#39;,</span>
<span class="sd">    ...            label=r&quot;$J_3$_Zeros&quot;, zorder=5)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(0, 0, s=30, c=&#39;k&#39;,</span>
<span class="sd">    ...            label=r&quot;Root at 0&quot;, zorder=5)</span>
<span class="sd">    &gt;&gt;&gt; ax.hlines(0, 0, xmax, color=&#39;k&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_xlim(xmin, xmax)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">jnp_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel function derivatives Jn&#39;.</span>

<span class="sd">    Compute `nt` zeros of the functions :math:`J_n&#39;(x)` on the</span>
<span class="sd">    interval :math:`(0, \infty)`. The zeros are returned in ascending</span>
<span class="sd">    order. Note that this interval excludes the zero at :math:`x = 0`</span>
<span class="sd">    that exists for :math:`n &gt; 1`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Bessel function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    jvp: Derivatives of integer-order Bessel functions of the first kind</span>
<span class="sd">    jv: Float-order Bessel functions of the first kind</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the first four roots of :math:`J_2&#39;`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import jnp_zeros</span>
<span class="sd">    &gt;&gt;&gt; jnp_zeros(2, 4)</span>
<span class="sd">    array([ 3.05423693,  6.70613319,  9.96946782, 13.17037086])</span>

<span class="sd">    As `jnp_zeros` yields the roots of :math:`J_n&#39;`, it can be used to</span>
<span class="sd">    compute the locations of the peaks of :math:`J_n`. Plot</span>
<span class="sd">    :math:`J_2`, :math:`J_2&#39;` and the locations of the roots of :math:`J_2&#39;`.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import jn, jnp_zeros, jvp</span>
<span class="sd">    &gt;&gt;&gt; j2_roots = jnp_zeros(2, 4)</span>
<span class="sd">    &gt;&gt;&gt; xmax = 15</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, xmax, 500)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, jn(2, x), label=r&#39;$J_2$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, jvp(2, x, 1), label=r&quot;$J_2&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.hlines(0, 0, xmax, color=&#39;k&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(j2_roots, np.zeros((4, )), s=30, c=&#39;r&#39;,</span>
<span class="sd">    ...            label=r&quot;Roots of $J_2&#39;$&quot;, zorder=5)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-0.4, 0.8)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_xlim(0, xmax)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">yn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel function Yn(x).</span>

<span class="sd">    Compute `nt` zeros of the functions :math:`Y_n(x)` on the interval</span>
<span class="sd">    :math:`(0, \infty)`. The zeros are returned in ascending order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Bessel function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    yn: Bessel function of the second kind for integer order</span>
<span class="sd">    yv: Bessel function of the second kind for real order</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the first four roots of :math:`Y_2`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import yn_zeros</span>
<span class="sd">    &gt;&gt;&gt; yn_zeros(2, 4)</span>
<span class="sd">    array([ 3.38424177,  6.79380751, 10.02347798, 13.20998671])</span>

<span class="sd">    Plot :math:`Y_2` and its first four roots.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import yn, yn_zeros</span>
<span class="sd">    &gt;&gt;&gt; xmin = 2</span>
<span class="sd">    &gt;&gt;&gt; xmax = 15</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(xmin, xmax, 500)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.hlines(0, xmin, xmax, color=&#39;k&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, yn(2, x), label=r&#39;$Y_2$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(yn_zeros(2, 4), np.zeros((4, )), s=30, c=&#39;r&#39;,</span>
<span class="sd">    ...            label=&#39;Roots&#39;, zorder=5)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-0.4, 0.4)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_xlim(xmin, xmax)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">ynp_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute zeros of integer-order Bessel function derivatives Yn&#39;(x).</span>

<span class="sd">    Compute `nt` zeros of the functions :math:`Y_n&#39;(x)` on the</span>
<span class="sd">    interval :math:`(0, \infty)`. The zeros are returned in ascending</span>
<span class="sd">    order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Bessel derivative function.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    yvp</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the first four roots of the first derivative of the</span>
<span class="sd">    Bessel function of second kind for order 0 :math:`Y_0&#39;`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import ynp_zeros</span>
<span class="sd">    &gt;&gt;&gt; ynp_zeros(0, 4)</span>
<span class="sd">    array([ 2.19714133,  5.42968104,  8.59600587, 11.74915483])</span>

<span class="sd">    Plot :math:`Y_0`, :math:`Y_0&#39;` and confirm visually that the roots of</span>
<span class="sd">    :math:`Y_0&#39;` are located at local extrema of :math:`Y_0`.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import yn, ynp_zeros, yvp</span>
<span class="sd">    &gt;&gt;&gt; zeros = ynp_zeros(0, 4)</span>
<span class="sd">    &gt;&gt;&gt; xmax = 13</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, xmax, 500)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, yn(0, x), label=r&#39;$Y_0$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, yvp(0, x, 1), label=r&quot;$Y_0&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(zeros, np.zeros((4, )), s=30, c=&#39;r&#39;,</span>
<span class="sd">    ...            label=r&quot;Roots of $Y_0&#39;$&quot;, zorder=5)</span>
<span class="sd">    &gt;&gt;&gt; for root in zeros:</span>
<span class="sd">    ...     y0_extremum =  yn(0, root)</span>
<span class="sd">    ...     lower = min(0, y0_extremum)</span>
<span class="sd">    ...     upper = max(0, y0_extremum)</span>
<span class="sd">    ...     ax.vlines(root, lower, upper, color=&#39;r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.hlines(0, 0, xmax, color=&#39;k&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-0.6, 0.6)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_xlim(0, xmax)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jnyn_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">y0_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel function Y0(z), and derivative at each zero.</span>

<span class="sd">    The derivatives are given by Y0&#39;(z0) = -Y1(z0) at each zero z0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>
<span class="sd">    complex : bool, default False</span>
<span class="sd">        Set to False to return only the real zeros; set to True to return only</span>
<span class="sd">        the complex zeros with negative real part and positive imaginary part.</span>
<span class="sd">        Note that the complex conjugates of the latter are also zeros of the</span>
<span class="sd">        function, but are not returned by this routine.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z0n : ndarray</span>
<span class="sd">        Location of nth zero of Y0(z)</span>
<span class="sd">    y0pz0n : ndarray</span>
<span class="sd">        Value of derivative Y0&#39;(z0) for nth zero</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the first 4 real roots and the derivatives at the roots of</span>
<span class="sd">    :math:`Y_0`:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import y0_zeros</span>
<span class="sd">    &gt;&gt;&gt; zeros, grads = y0_zeros(4)</span>
<span class="sd">    &gt;&gt;&gt; with np.printoptions(precision=5):</span>
<span class="sd">    ...     print(f&quot;Roots: {zeros}&quot;)</span>
<span class="sd">    ...     print(f&quot;Gradients: {grads}&quot;)</span>
<span class="sd">    Roots: [ 0.89358+0.j  3.95768+0.j  7.08605+0.j 10.22235+0.j]</span>
<span class="sd">    Gradients: [-0.87942+0.j  0.40254+0.j -0.3001 +0.j  0.2497 +0.j]</span>

<span class="sd">    Plot the real part of :math:`Y_0` and the first four computed roots.</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import y0</span>
<span class="sd">    &gt;&gt;&gt; xmin = 0</span>
<span class="sd">    &gt;&gt;&gt; xmax = 11</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(xmin, xmax, 500)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.hlines(0, xmin, xmax, color=&#39;k&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, y0(x), label=r&#39;$Y_0$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; zeros, grads = y0_zeros(4)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(zeros.real, np.zeros((4, )), s=30, c=&#39;r&#39;,</span>
<span class="sd">    ...            label=r&#39;$Y_0$_zeros&#39;, zorder=5)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-0.5, 0.6)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_xlim(xmin, xmax)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(ncol=2)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Compute the first 4 complex roots and the derivatives at the roots of</span>
<span class="sd">    :math:`Y_0` by setting ``complex=True``:</span>

<span class="sd">    &gt;&gt;&gt; y0_zeros(4, True)</span>
<span class="sd">    (array([ -2.40301663+0.53988231j,  -5.5198767 +0.54718001j,</span>
<span class="sd">             -8.6536724 +0.54841207j, -11.79151203+0.54881912j]),</span>
<span class="sd">     array([ 0.10074769-0.88196771j, -0.02924642+0.5871695j ,</span>
<span class="sd">             0.01490806-0.46945875j, -0.00937368+0.40230454j]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalar positive integer.&quot;</span><span class="p">)</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">kc</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">complex</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">cyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">,</span> <span class="n">kc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">y1_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel function Y1(z), and derivative at each zero.</span>

<span class="sd">    The derivatives are given by Y1&#39;(z1) = Y0(z1) at each zero z1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>
<span class="sd">    complex : bool, default False</span>
<span class="sd">        Set to False to return only the real zeros; set to True to return only</span>
<span class="sd">        the complex zeros with negative real part and positive imaginary part.</span>
<span class="sd">        Note that the complex conjugates of the latter are also zeros of the</span>
<span class="sd">        function, but are not returned by this routine.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z1n : ndarray</span>
<span class="sd">        Location of nth zero of Y1(z)</span>
<span class="sd">    y1pz1n : ndarray</span>
<span class="sd">        Value of derivative Y1&#39;(z1) for nth zero</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the first 4 real roots and the derivatives at the roots of</span>
<span class="sd">    :math:`Y_1`:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import y1_zeros</span>
<span class="sd">    &gt;&gt;&gt; zeros, grads = y1_zeros(4)</span>
<span class="sd">    &gt;&gt;&gt; with np.printoptions(precision=5):</span>
<span class="sd">    ...     print(f&quot;Roots: {zeros}&quot;)</span>
<span class="sd">    ...     print(f&quot;Gradients: {grads}&quot;)</span>
<span class="sd">    Roots: [ 2.19714+0.j  5.42968+0.j  8.59601+0.j 11.74915+0.j]</span>
<span class="sd">    Gradients: [ 0.52079+0.j -0.34032+0.j  0.27146+0.j -0.23246+0.j]</span>

<span class="sd">    Extract the real parts:</span>

<span class="sd">    &gt;&gt;&gt; realzeros = zeros.real</span>
<span class="sd">    &gt;&gt;&gt; realzeros</span>
<span class="sd">    array([ 2.19714133,  5.42968104,  8.59600587, 11.74915483])</span>

<span class="sd">    Plot :math:`Y_1` and the first four computed roots.</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import y1</span>
<span class="sd">    &gt;&gt;&gt; xmin = 0</span>
<span class="sd">    &gt;&gt;&gt; xmax = 13</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(xmin, xmax, 500)</span>
<span class="sd">    &gt;&gt;&gt; zeros, grads = y1_zeros(4)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.hlines(0, xmin, xmax, color=&#39;k&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, y1(x), label=r&#39;$Y_1$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(zeros.real, np.zeros((4, )), s=30, c=&#39;r&#39;,</span>
<span class="sd">    ...            label=r&#39;$Y_1$_zeros&#39;, zorder=5)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-0.5, 0.5)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_xlim(xmin, xmax)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Compute the first 4 complex roots and the derivatives at the roots of</span>
<span class="sd">    :math:`Y_1` by setting ``complex=True``:</span>

<span class="sd">    &gt;&gt;&gt; y1_zeros(4, True)</span>
<span class="sd">    (array([ -0.50274327+0.78624371j,  -3.83353519+0.56235654j,</span>
<span class="sd">             -7.01590368+0.55339305j, -10.17357383+0.55127339j]),</span>
<span class="sd">     array([-0.45952768+1.31710194j,  0.04830191-0.69251288j,</span>
<span class="sd">            -0.02012695+0.51864253j,  0.011614  -0.43203296j]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalar positive integer.&quot;</span><span class="p">)</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">kc</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">complex</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">cyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">,</span> <span class="n">kc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">y1p_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of Bessel derivative Y1&#39;(z), and value at each zero.</span>

<span class="sd">    The values are given by Y1(z1) at each z1 where Y1&#39;(z1)=0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to return</span>
<span class="sd">    complex : bool, default False</span>
<span class="sd">        Set to False to return only the real zeros; set to True to return only</span>
<span class="sd">        the complex zeros with negative real part and positive imaginary part.</span>
<span class="sd">        Note that the complex conjugates of the latter are also zeros of the</span>
<span class="sd">        function, but are not returned by this routine.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z1pn : ndarray</span>
<span class="sd">        Location of nth zero of Y1&#39;(z)</span>
<span class="sd">    y1z1pn : ndarray</span>
<span class="sd">        Value of derivative Y1(z1) for nth zero</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the first four roots of :math:`Y_1&#39;` and the values of</span>
<span class="sd">    :math:`Y_1` at these roots.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import y1p_zeros</span>
<span class="sd">    &gt;&gt;&gt; y1grad_roots, y1_values = y1p_zeros(4)</span>
<span class="sd">    &gt;&gt;&gt; with np.printoptions(precision=5):</span>
<span class="sd">    ...     print(f&quot;Y1&#39; Roots: {y1grad_roots}&quot;)</span>
<span class="sd">    ...     print(f&quot;Y1 values: {y1_values}&quot;)</span>
<span class="sd">    Y1&#39; Roots: [ 3.68302+0.j  6.9415 +0.j 10.1234 +0.j 13.28576+0.j]</span>
<span class="sd">    Y1 values: [ 0.41673+0.j -0.30317+0.j  0.25091+0.j -0.21897+0.j]</span>

<span class="sd">    `y1p_zeros` can be used to calculate the extremal points of :math:`Y_1`</span>
<span class="sd">    directly. Here we plot :math:`Y_1` and the first four extrema.</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import y1, yvp</span>
<span class="sd">    &gt;&gt;&gt; y1_roots, y1_values_at_roots = y1p_zeros(4)</span>
<span class="sd">    &gt;&gt;&gt; real_roots = y1_roots.real</span>
<span class="sd">    &gt;&gt;&gt; xmax = 15</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, xmax, 500)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, y1(x), label=r&#39;$Y_1$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 1), label=r&quot;$Y_1&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(real_roots, np.zeros((4, )), s=30, c=&#39;r&#39;,</span>
<span class="sd">    ...            label=r&quot;Roots of $Y_1&#39;$&quot;, zorder=5)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(real_roots, y1_values_at_roots.real, s=30, c=&#39;k&#39;,</span>
<span class="sd">    ...            label=r&quot;Extrema of $Y_1$&quot;, zorder=5)</span>
<span class="sd">    &gt;&gt;&gt; ax.hlines(0, 0, xmax, color=&#39;k&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-0.5, 0.5)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_xlim(0, xmax)</span>
<span class="sd">    &gt;&gt;&gt; ax.legend(ncol=2, bbox_to_anchor=(1., 0.75))</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalar positive integer.&quot;</span><span class="p">)</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">kc</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">complex</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">cyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">,</span> <span class="n">kc</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
    <span class="c1"># from AMS55.</span>
    <span class="c1"># L(v, z) = J(v, z), Y(v, z), H1(v, z), H2(v, z), phase = -1</span>
    <span class="c1"># L(v, z) = I(v, z) or exp(v*pi*i)K(v, z), phase = 1</span>
    <span class="c1"># For K, you can pull out the exp((v-k)*pi*i) into the caller</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">phase</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">i</span>   <span class="c1"># = choose(k, i)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">p</span><span class="o">*</span><span class="n">L</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">jvp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute derivatives of Bessel functions of the first kind.</span>

<span class="sd">    Compute the nth derivative of the Bessel function `Jv` with</span>
<span class="sd">    respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like or float</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate the derivative; can be real or</span>
<span class="sd">        complex.</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative. For 0 returns the Bessel function `jv` itself.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar or ndarray</span>
<span class="sd">        Values of the derivative of the Bessel function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Compute the Bessel function of the first kind of order 0 and</span>
<span class="sd">    its first two derivatives at 1.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import jvp</span>
<span class="sd">    &gt;&gt;&gt; jvp(0, 1, 0), jvp(0, 1, 1), jvp(0, 1, 2)</span>
<span class="sd">    (0.7651976865579666, -0.44005058574493355, -0.3251471008130331)</span>

<span class="sd">    Compute the first derivative of the Bessel function of the first</span>
<span class="sd">    kind for several orders at 1 by providing an array for `v`.</span>

<span class="sd">    &gt;&gt;&gt; jvp([0, 1, 2], 1, 1)</span>
<span class="sd">    array([-0.44005059,  0.3251471 ,  0.21024362])</span>

<span class="sd">    Compute the first derivative of the Bessel function of the first</span>
<span class="sd">    kind of order 0 at several points by providing an array for `z`.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; points = np.array([0., 1.5, 3.])</span>
<span class="sd">    &gt;&gt;&gt; jvp(0, points, 1)</span>
<span class="sd">    array([-0.        , -0.55793651, -0.33905896])</span>

<span class="sd">    Plot the Bessel function of the first kind of order 1 and its</span>
<span class="sd">    first three derivatives.</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, jvp(1, x, 0), label=r&quot;$J_1$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, jvp(1, x, 1), label=r&quot;$J_1&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, jvp(1, x, 2), label=r&quot;$J_1&#39;&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, jvp(1, x, 3), label=r&quot;$J_1&#39;&#39;&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">jv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">jv</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">yvp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute derivatives of Bessel functions of the second kind.</span>

<span class="sd">    Compute the nth derivative of the Bessel function `Yv` with</span>
<span class="sd">    respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like of float</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Argument at which to evaluate the derivative</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative. For 0 returns the BEssel function `yv`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    yv</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar or ndarray</span>
<span class="sd">        nth derivative of the Bessel function.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the Bessel function of the second kind of order 0 and</span>
<span class="sd">    its first two derivatives at 1.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import yvp</span>
<span class="sd">    &gt;&gt;&gt; yvp(0, 1, 0), yvp(0, 1, 1), yvp(0, 1, 2)</span>
<span class="sd">    (0.088256964215677, 0.7812128213002889, -0.8694697855159659)</span>

<span class="sd">    Compute the first derivative of the Bessel function of the second</span>
<span class="sd">    kind for several orders at 1 by providing an array for `v`.</span>

<span class="sd">    &gt;&gt;&gt; yvp([0, 1, 2], 1, 1)</span>
<span class="sd">    array([0.78121282, 0.86946979, 2.52015239])</span>

<span class="sd">    Compute the first derivative of the Bessel function of the</span>
<span class="sd">    second kind of order 0 at several points by providing an array for `z`.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; points = np.array([0.5, 1.5, 3.])</span>
<span class="sd">    &gt;&gt;&gt; yvp(0, points, 1)</span>
<span class="sd">    array([ 1.47147239,  0.41230863, -0.32467442])</span>

<span class="sd">    Plot the Bessel function of the second kind of order 1 and its</span>
<span class="sd">    first three derivatives.</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 5, 1000)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 0), label=r&quot;$Y_1$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 1), label=r&quot;$Y_1&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 2), label=r&quot;$Y_1&#39;&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 3), label=r&quot;$Y_1&#39;&#39;&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-10, 10)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">yv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kvp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute derivatives of real-order modified Bessel function Kv(z)</span>

<span class="sd">    Kv(z) is the modified Bessel function of the second kind.</span>
<span class="sd">    Derivative is calculated with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like of float</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : array_like of complex</span>
<span class="sd">        Argument at which to evaluate the derivative</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative. For 0 returns the Bessel function `kv` itself.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The results</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    kv</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.29.5 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 6.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.29.E5</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the modified bessel function of the second kind of order 0 and</span>
<span class="sd">    its first two derivatives at 1.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import kvp</span>
<span class="sd">    &gt;&gt;&gt; kvp(0, 1, 0), kvp(0, 1, 1), kvp(0, 1, 2)</span>
<span class="sd">    (0.42102443824070834, -0.6019072301972346, 1.0229316684379428)</span>

<span class="sd">    Compute the first derivative of the modified Bessel function of the second</span>
<span class="sd">    kind for several orders at 1 by providing an array for `v`.</span>

<span class="sd">    &gt;&gt;&gt; kvp([0, 1, 2], 1, 1)</span>
<span class="sd">    array([-0.60190723, -1.02293167, -3.85158503])</span>

<span class="sd">    Compute the first derivative of the modified Bessel function of the</span>
<span class="sd">    second kind of order 0 at several points by providing an array for `z`.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; points = np.array([0.5, 1.5, 3.])</span>
<span class="sd">    &gt;&gt;&gt; kvp(0, points, 1)</span>
<span class="sd">    array([-1.65644112, -0.2773878 , -0.04015643])</span>

<span class="sd">    Plot the modified bessel function of the second kind and its</span>
<span class="sd">    first three derivatives.</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 5, 1000)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, kvp(1, x, 0), label=r&quot;$K_1$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, kvp(1, x, 1), label=r&quot;$K_1&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, kvp(1, x, 2), label=r&quot;$K_1&#39;&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, kvp(1, x, 3), label=r&quot;$K_1&#39;&#39;&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.set_ylim(-2.5, 2.5)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">kv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ivp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute derivatives of modified Bessel functions of the first kind.</span>

<span class="sd">    Compute the nth derivative of the modified Bessel function `Iv`</span>
<span class="sd">    with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like or float</span>
<span class="sd">        Order of Bessel function</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Argument at which to evaluate the derivative; can be real or</span>
<span class="sd">        complex.</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative. For 0, returns the Bessel function `iv` itself.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar or ndarray</span>
<span class="sd">        nth derivative of the modified Bessel function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    iv</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.29.5 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 6.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.29.E5</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the modified Bessel function of the first kind of order 0 and</span>
<span class="sd">    its first two derivatives at 1.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import ivp</span>
<span class="sd">    &gt;&gt;&gt; ivp(0, 1, 0), ivp(0, 1, 1), ivp(0, 1, 2)</span>
<span class="sd">    (1.2660658777520084, 0.565159103992485, 0.7009067737595233)</span>

<span class="sd">    Compute the first derivative of the modified Bessel function of the first</span>
<span class="sd">    kind for several orders at 1 by providing an array for `v`.</span>

<span class="sd">    &gt;&gt;&gt; ivp([0, 1, 2], 1, 1)</span>
<span class="sd">    array([0.5651591 , 0.70090677, 0.29366376])</span>

<span class="sd">    Compute the first derivative of the modified Bessel function of the</span>
<span class="sd">    first kind of order 0 at several points by providing an array for `z`.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; points = np.array([0., 1.5, 3.])</span>
<span class="sd">    &gt;&gt;&gt; ivp(0, points, 1)</span>
<span class="sd">    array([0.        , 0.98166643, 3.95337022])</span>

<span class="sd">    Plot the modified Bessel function of the first kind of order 1 and its</span>
<span class="sd">    first three derivatives.</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, ivp(1, x, 0), label=r&quot;$I_1$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, ivp(1, x, 1), label=r&quot;$I_1&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, ivp(1, x, 2), label=r&quot;$I_1&#39;&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(x, ivp(1, x, 3), label=r&quot;$I_1&#39;&#39;&#39;$&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">iv</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">h1vp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute derivatives of Hankel function H1v(z) with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like</span>
<span class="sd">        Order of Hankel function</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Argument at which to evaluate the derivative. Can be real or</span>
<span class="sd">        complex.</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative. For 0 returns the Hankel function `h1v` itself.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar or ndarray</span>
<span class="sd">        Values of the derivative of the Hankel function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    hankel1</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the Hankel function of the first kind of order 0 and</span>
<span class="sd">    its first two derivatives at 1.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import h1vp</span>
<span class="sd">    &gt;&gt;&gt; h1vp(0, 1, 0), h1vp(0, 1, 1), h1vp(0, 1, 2)</span>
<span class="sd">    ((0.7651976865579664+0.088256964215677j),</span>
<span class="sd">     (-0.44005058574493355+0.7812128213002889j),</span>
<span class="sd">     (-0.3251471008130329-0.8694697855159659j))</span>

<span class="sd">    Compute the first derivative of the Hankel function of the first kind</span>
<span class="sd">    for several orders at 1 by providing an array for `v`.</span>

<span class="sd">    &gt;&gt;&gt; h1vp([0, 1, 2], 1, 1)</span>
<span class="sd">    array([-0.44005059+0.78121282j,  0.3251471 +0.86946979j,</span>
<span class="sd">           0.21024362+2.52015239j])</span>

<span class="sd">    Compute the first derivative of the Hankel function of the first kind</span>
<span class="sd">    of order 0 at several points by providing an array for `z`.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; points = np.array([0.5, 1.5, 3.])</span>
<span class="sd">    &gt;&gt;&gt; h1vp(0, points, 1)</span>
<span class="sd">    array([-0.24226846+1.47147239j, -0.55793651+0.41230863j,</span>
<span class="sd">           -0.33905896-0.32467442j])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hankel1</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hankel1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">h2vp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute derivatives of Hankel function H2v(z) with respect to `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array_like</span>
<span class="sd">        Order of Hankel function</span>
<span class="sd">    z : array_like</span>
<span class="sd">        Argument at which to evaluate the derivative. Can be real or</span>
<span class="sd">        complex.</span>
<span class="sd">    n : int, default 1</span>
<span class="sd">        Order of derivative. For 0 returns the Hankel function `h2v` itself.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar or ndarray</span>
<span class="sd">        Values of the derivative of the Hankel function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    hankel2</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The derivative is computed using the relation DLFM 10.6.7 [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 5.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.6.E7</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the Hankel function of the second kind of order 0 and</span>
<span class="sd">    its first two derivatives at 1.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import h2vp</span>
<span class="sd">    &gt;&gt;&gt; h2vp(0, 1, 0), h2vp(0, 1, 1), h2vp(0, 1, 2)</span>
<span class="sd">    ((0.7651976865579664-0.088256964215677j),</span>
<span class="sd">     (-0.44005058574493355-0.7812128213002889j),</span>
<span class="sd">     (-0.3251471008130329+0.8694697855159659j))</span>

<span class="sd">    Compute the first derivative of the Hankel function of the second kind</span>
<span class="sd">    for several orders at 1 by providing an array for `v`.</span>

<span class="sd">    &gt;&gt;&gt; h2vp([0, 1, 2], 1, 1)</span>
<span class="sd">    array([-0.44005059-0.78121282j,  0.3251471 -0.86946979j,</span>
<span class="sd">           0.21024362-2.52015239j])</span>

<span class="sd">    Compute the first derivative of the Hankel function of the second kind</span>
<span class="sd">    of order 0 at several points by providing an array for `z`.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; points = np.array([0.5, 1.5, 3.])</span>
<span class="sd">    &gt;&gt;&gt; h2vp(0, points, 1)</span>
<span class="sd">    array([-0.24226846-1.47147239j, -0.55793651-0.41230863j,</span>
<span class="sd">           -0.33905896+0.32467442j])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hankel2</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_bessel_diff_formula</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">hankel2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">riccati_jn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute Ricatti-Bessel function of the first kind and its derivative.</span>

<span class="sd">    The Ricatti-Bessel function of the first kind is defined as :math:`x</span>
<span class="sd">    j_n(x)`, where :math:`j_n` is the spherical Bessel function of the first</span>
<span class="sd">    kind of order :math:`n`.</span>

<span class="sd">    This function computes the value and first derivative of the</span>
<span class="sd">    Ricatti-Bessel function for all orders up to and including `n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of function to compute</span>
<span class="sd">    x : float</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jn : ndarray</span>
<span class="sd">        Value of j0(x), ..., jn(x)</span>
<span class="sd">    jnp : ndarray</span>
<span class="sd">        First derivative j0&#39;(x), ..., jn&#39;(x)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The computation is carried out via backward recurrence, using the</span>
<span class="sd">    relation DLMF 10.51.1 [2]_.</span>

<span class="sd">    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming</span>
<span class="sd">    Jin [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.51.E1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">nm</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">jnp</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">rctj</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">jnp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">riccati_yn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Ricatti-Bessel function of the second kind and its derivative.</span>

<span class="sd">    The Ricatti-Bessel function of the second kind is defined as :math:`x</span>
<span class="sd">    y_n(x)`, where :math:`y_n` is the spherical Bessel function of the second</span>
<span class="sd">    kind of order :math:`n`.</span>

<span class="sd">    This function computes the value and first derivative of the function for</span>
<span class="sd">    all orders up to and including `n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Maximum order of function to compute</span>
<span class="sd">    x : float</span>
<span class="sd">        Argument at which to evaluate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    yn : ndarray</span>
<span class="sd">        Value of y0(x), ..., yn(x)</span>
<span class="sd">    ynp : ndarray</span>
<span class="sd">        First derivative y0&#39;(x), ..., yn&#39;(x)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The computation is carried out via ascending recurrence, using the</span>
<span class="sd">    relation DLMF 10.51.1 [2]_.</span>

<span class="sd">    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming</span>
<span class="sd">    Jin [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions.</span>
<span class="sd">           https://dlmf.nist.gov/10.51.E1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">nm</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">jnp</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">rcty</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">jnp</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">erf_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the first nt zero in the first quadrant, ordered by absolute value.</span>

<span class="sd">    Zeros in the other quadrants can be obtained by using the symmetries erf(-z) = erf(z) and</span>
<span class="sd">    erf(conj(z)) = conj(erf(z)).</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        The number of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The locations of the zeros of erf : ndarray (complex)</span>
<span class="sd">        Complex values at which zeros of erf(z)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; special.erf_zeros(1)</span>
<span class="sd">    array([1.45061616+1.880943j])</span>

<span class="sd">    Check that erf is (close to) zero for the value returned by erf_zeros</span>

<span class="sd">    &gt;&gt;&gt; special.erf(special.erf_zeros(1))</span>
<span class="sd">    array([4.95159469e-14-1.16407394e-16j])</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">cerzo</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fresnelc_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt complex zeros of cosine Fresnel integral C(z).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fresnels_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt complex zeros of sine Fresnel integral S(z).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fresnel_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt complex zeros of sine and cosine Fresnel integrals S(z) and C(z).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be positive scalar integer.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nt</span><span class="p">),</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">fcszo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">assoc_laguerre</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the generalized (associated) Laguerre polynomial of degree n and order k.</span>

<span class="sd">    The polynomial :math:`L^{(k)}_n(x)` is orthogonal over ``[0, inf)``,</span>
<span class="sd">    with weighting function ``exp(-x) * x**k`` with ``k &gt; -1``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `assoc_laguerre` is a simple wrapper around `eval_genlaguerre`, with</span>
<span class="sd">    reversed argument order ``(x, n, k=0.0) --&gt; (n, k, x)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">eval_genlaguerre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="n">digamma</span> <span class="o">=</span> <span class="n">psi</span>


<span class="k">def</span> <span class="nf">polygamma</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Polygamma functions.</span>

<span class="sd">    Defined as :math:`\psi^{(n)}(x)` where :math:`\psi` is the</span>
<span class="sd">    `digamma` function. See [dlmf]_ for details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : array_like</span>
<span class="sd">        The order of the derivative of the digamma function; must be</span>
<span class="sd">        integral</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Real valued input</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Function results</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    digamma</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [dlmf] NIST, Digital Library of Mathematical Functions,</span>
<span class="sd">        https://dlmf.nist.gov/5.15</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; x = [2, 3, 25.5]</span>
<span class="sd">    &gt;&gt;&gt; special.polygamma(1, x)</span>
<span class="sd">    array([ 0.64493407,  0.39493407,  0.03999467])</span>
<span class="sd">    &gt;&gt;&gt; special.polygamma(0, x) == special.psi(x)</span>
<span class="sd">    array([ True,  True,  True], dtype=bool)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">fac2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">zeta</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">fac2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mathieu_even_coef</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fourier coefficients for even Mathieu and modified Mathieu functions.</span>

<span class="sd">    The Fourier series of the even solutions of the Mathieu differential</span>
<span class="sd">    equation are of the form</span>

<span class="sd">    .. math:: \mathrm{ce}_{2n}(z, q) = \sum_{k=0}^{\infty} A_{(2n)}^{(2k)} \cos 2kz</span>

<span class="sd">    .. math:: \mathrm{ce}_{2n+1}(z, q) = \sum_{k=0}^{\infty} A_{(2n+1)}^{(2k+1)} \cos (2k+1)z</span>

<span class="sd">    This function returns the coefficients :math:`A_{(2n)}^{(2k)}` for even</span>
<span class="sd">    input m=2n, and the coefficients :math:`A_{(2n+1)}^{(2k+1)}` for odd input</span>
<span class="sd">    m=2n+1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">        Order of Mathieu functions.  Must be non-negative.</span>
<span class="sd">    q : float (&gt;=0)</span>
<span class="sd">        Parameter of Mathieu functions.  Must be non-negative.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Ak : ndarray</span>
<span class="sd">        Even or odd Fourier coefficients, corresponding to even or odd m.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions</span>
<span class="sd">           https://dlmf.nist.gov/28.4#i</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m and q must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q &gt;=0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be an integer &gt;=0.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">7.5</span> <span class="o">+</span> <span class="mf">56.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="mf">134.7</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="mf">90.7</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">17.0</span> <span class="o">+</span> <span class="mf">3.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="mf">.126</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="mf">.0037</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="n">km</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qm</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">km</span> <span class="o">&gt;</span> <span class="mi">251</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Too many predicted coefficients.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">kd</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">kd</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">mathieu_a</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">fcoef</span><span class="p">(</span><span class="n">kd</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fc</span><span class="p">[:</span><span class="n">km</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">mathieu_odd_coef</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fourier coefficients for even Mathieu and modified Mathieu functions.</span>

<span class="sd">    The Fourier series of the odd solutions of the Mathieu differential</span>
<span class="sd">    equation are of the form</span>

<span class="sd">    .. math:: \mathrm{se}_{2n+1}(z, q) = \sum_{k=0}^{\infty} B_{(2n+1)}^{(2k+1)} \sin (2k+1)z</span>

<span class="sd">    .. math:: \mathrm{se}_{2n+2}(z, q) = \sum_{k=0}^{\infty} B_{(2n+2)}^{(2k+2)} \sin (2k+2)z</span>

<span class="sd">    This function returns the coefficients :math:`B_{(2n+2)}^{(2k+2)}` for even</span>
<span class="sd">    input m=2n+2, and the coefficients :math:`B_{(2n+1)}^{(2k+1)}` for odd</span>
<span class="sd">    input m=2n+1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">        Order of Mathieu functions.  Must be non-negative.</span>
<span class="sd">    q : float (&gt;=0)</span>
<span class="sd">        Parameter of Mathieu functions.  Must be non-negative.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Bk : ndarray</span>
<span class="sd">        Even or odd Fourier coefficients, corresponding to even or odd m.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">q</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m and q must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q &gt;=0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be an integer &gt; 0&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">7.5</span> <span class="o">+</span> <span class="mf">56.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="mf">134.7</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="mf">90.7</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="mf">17.0</span> <span class="o">+</span> <span class="mf">3.1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="mf">.126</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="mf">.0037</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span>
    <span class="n">km</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qm</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">km</span> <span class="o">&gt;</span> <span class="mi">251</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Too many predicted coefficients.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">kd</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">kd</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">mathieu_b</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">fcoef</span><span class="p">(</span><span class="n">kd</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fc</span><span class="p">[:</span><span class="n">km</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">lpmn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sequence of associated Legendre functions of the first kind.</span>

<span class="sd">    Computes the associated Legendre function of the first kind of order m and</span>
<span class="sd">    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn&#39;(z)``.</span>
<span class="sd">    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and</span>
<span class="sd">    ``Pmn&#39;(z)`` for all orders from ``0..m`` and degrees from ``0..n``.</span>

<span class="sd">    This function takes a real argument ``z``. For complex arguments ``z``</span>
<span class="sd">    use clpmn instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">       ``|m| &lt;= n``; the order of the Legendre function.</span>
<span class="sd">    n : int</span>
<span class="sd">       where ``n &gt;= 0``; the degree of the Legendre function.  Often</span>
<span class="sd">       called ``l`` (lower case L) in descriptions of the associated</span>
<span class="sd">       Legendre function</span>
<span class="sd">    z : float</span>
<span class="sd">        Input value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pmn_z : (m+1, n+1) array</span>
<span class="sd">       Values for all orders 0..m and degrees 0..n</span>
<span class="sd">    Pmn_d_z : (m+1, n+1) array</span>
<span class="sd">       Derivatives for all orders 0..m and degrees 0..n</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    clpmn: associated Legendre functions of the first kind for complex z</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the interval (-1, 1), Ferrer&#39;s function of the first kind is</span>
<span class="sd">    returned. The phase convention used for the intervals (1, inf)</span>
<span class="sd">    and (-inf, -1) is such that the result is always real.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions</span>
<span class="sd">           https://dlmf.nist.gov/14.3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be &lt;= n.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;z must be scalar.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument must be real. Use clpmn instead.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="o">-</span><span class="n">m</span>
        <span class="n">mf</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">mp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Ferrer function; DLMF 14.9.3</span>
                <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                               <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">mf</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Match to clpmn; DLMF 14.9.13</span>
                <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">m</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">lpmn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">fixarr</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="n">pd</span> <span class="o">*</span> <span class="n">fixarr</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">pd</span>


<span class="k">def</span> <span class="nf">clpmn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Associated Legendre function of the first kind for complex arguments.</span>

<span class="sd">    Computes the associated Legendre function of the first kind of order m and</span>
<span class="sd">    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn&#39;(z)``.</span>
<span class="sd">    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and</span>
<span class="sd">    ``Pmn&#39;(z)`` for all orders from ``0..m`` and degrees from ``0..n``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">       ``|m| &lt;= n``; the order of the Legendre function.</span>
<span class="sd">    n : int</span>
<span class="sd">       where ``n &gt;= 0``; the degree of the Legendre function.  Often</span>
<span class="sd">       called ``l`` (lower case L) in descriptions of the associated</span>
<span class="sd">       Legendre function</span>
<span class="sd">    z : float or complex</span>
<span class="sd">        Input value.</span>
<span class="sd">    type : int, optional</span>
<span class="sd">       takes values 2 or 3</span>
<span class="sd">       2: cut on the real axis ``|x| &gt; 1``</span>
<span class="sd">       3: cut on the real axis ``-1 &lt; x &lt; 1`` (default)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pmn_z : (m+1, n+1) array</span>
<span class="sd">       Values for all orders ``0..m`` and degrees ``0..n``</span>
<span class="sd">    Pmn_d_z : (m+1, n+1) array</span>
<span class="sd">       Derivatives for all orders ``0..m`` and degrees ``0..n``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lpmn: associated Legendre functions of the first kind for real z</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    By default, i.e. for ``type=3``, phase conventions are chosen according</span>
<span class="sd">    to [1]_ such that the function is analytic. The cut lies on the interval</span>
<span class="sd">    (-1, 1). Approaching the cut from above or below in general yields a phase</span>
<span class="sd">    factor with respect to Ferrer&#39;s function of the first kind</span>
<span class="sd">    (cf. `lpmn`).</span>

<span class="sd">    For ``type=2`` a cut at ``|x| &gt; 1`` is chosen. Approaching the real values</span>
<span class="sd">    on the interval (-1, 1) in the complex plane yields Ferrer&#39;s function</span>
<span class="sd">    of the first kind.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] NIST Digital Library of Mathematical Functions</span>
<span class="sd">           https://dlmf.nist.gov/14.21</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be &lt;= n.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;z must be scalar.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;type must be either 2 or 3.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="o">-</span><span class="n">m</span>
        <span class="n">mf</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">mp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                               <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">mf</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fixarr</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mf</span> <span class="o">&gt;</span> <span class="n">nf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nf</span><span class="o">+</span><span class="n">mf</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">m</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">clpmn</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">imag</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">type</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">fixarr</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="n">pd</span> <span class="o">*</span> <span class="n">fixarr</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">pd</span>


<span class="k">def</span> <span class="nf">lqmn</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sequence of associated Legendre functions of the second kind.</span>

<span class="sd">    Computes the associated Legendre function of the second kind of order m and</span>
<span class="sd">    degree n, ``Qmn(z)`` = :math:`Q_n^m(z)`, and its derivative, ``Qmn&#39;(z)``.</span>
<span class="sd">    Returns two arrays of size ``(m+1, n+1)`` containing ``Qmn(z)`` and</span>
<span class="sd">    ``Qmn&#39;(z)`` for all orders from ``0..m`` and degrees from ``0..n``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">       ``|m| &lt;= n``; the order of the Legendre function.</span>
<span class="sd">    n : int</span>
<span class="sd">       where ``n &gt;= 0``; the degree of the Legendre function.  Often</span>
<span class="sd">       called ``l`` (lower case L) in descriptions of the associated</span>
<span class="sd">       Legendre function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Input value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Qmn_z : (m+1, n+1) array</span>
<span class="sd">       Values for all orders 0..m and degrees 0..n</span>
<span class="sd">    Qmn_d_z : (m+1, n+1) array</span>
<span class="sd">       Derivatives for all orders 0..m and degrees 0..n</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;z must be scalar.&quot;</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Ensure neither m nor n == 0</span>
    <span class="n">mm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">clqmn</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">lqmn</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">q</span><span class="p">[:(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">qd</span><span class="p">[:(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">bernoulli</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bernoulli numbers B0..Bn (inclusive).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Indicated the number of terms in the Bernoulli series to generate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        The Bernoulli numbers ``[B(0), B(1), ..., B(n)]``.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] &quot;Bernoulli number&quot;, Wikipedia, https://en.wikipedia.org/wiki/Bernoulli_number</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import bernoulli, zeta</span>
<span class="sd">    &gt;&gt;&gt; bernoulli(4)</span>
<span class="sd">    array([ 1.        , -0.5       ,  0.16666667,  0.        , -0.03333333])</span>

<span class="sd">    The Wikipedia article ([2]_) points out the relationship between the</span>
<span class="sd">    Bernoulli numbers and the zeta function, ``B_n^+ = -n * zeta(1 - n)``</span>
<span class="sd">    for ``n &gt; 0``:</span>

<span class="sd">    &gt;&gt;&gt; n = np.arange(1, 5)</span>
<span class="sd">    &gt;&gt;&gt; -n * zeta(1 - n)</span>
<span class="sd">    array([ 0.5       ,  0.16666667, -0.        , -0.03333333])</span>

<span class="sd">    Note that, in the notation used in the wikipedia article,</span>
<span class="sd">    `bernoulli` computes ``B_n^-`` (i.e. it used the convention that</span>
<span class="sd">    ``B_1`` is -1/2).  The relation given above is for ``B_n^+``, so the</span>
<span class="sd">    sign of 0.5 does not match the output of ``bernoulli(4)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">bernob</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n1</span><span class="p">))[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">euler</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Euler numbers E(0), E(1), ..., E(n).</span>

<span class="sd">    The Euler numbers [1]_ are also known as the secant numbers.</span>

<span class="sd">    Because ``euler(n)`` returns floating point values, it does not give</span>
<span class="sd">    exact values for large `n`.  The first inexact value is E(22).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        The highest index of the Euler number to be returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        The Euler numbers [E(0), E(1), ..., E(n)].</span>
<span class="sd">        The odd Euler numbers, which are all zero, are included.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Sequence A122045, The On-Line Encyclopedia of Integer Sequences,</span>
<span class="sd">           https://oeis.org/A122045</span>
<span class="sd">    .. [2] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import euler</span>
<span class="sd">    &gt;&gt;&gt; euler(6)</span>
<span class="sd">    array([  1.,   0.,  -1.,   0.,   5.,   0., -61.])</span>

<span class="sd">    &gt;&gt;&gt; euler(13).astype(np.int64)</span>
<span class="sd">    array([      1,       0,      -1,       0,       5,       0,     -61,</span>
<span class="sd">                 0,    1385,       0,  -50521,       0, 2702765,       0])</span>

<span class="sd">    &gt;&gt;&gt; euler(22)[-1]  # Exact value of E(22) is -69348874393137901.</span>
<span class="sd">    -69348874393137976.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be a non-negative integer.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">eulerb</span><span class="p">(</span><span class="n">n1</span><span class="p">)[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">lpn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Legendre function of the first kind.</span>

<span class="sd">    Compute sequence of Legendre functions of the first kind (polynomials),</span>
<span class="sd">    Pn(z) and derivatives for all degrees from 0 to n (inclusive).</span>

<span class="sd">    See also special.legendre for polynomial class.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">pn</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">clpn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pn</span><span class="p">,</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">lpn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">pd</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">lqn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Legendre function of the second kind.</span>

<span class="sd">    Compute sequence of Legendre functions of the second kind, Qn(z) and</span>
<span class="sd">    derivatives for all degrees from 0 to n (inclusive).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_nonneg_int_or_fail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">qn</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">clqn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qn</span><span class="p">,</span> <span class="n">qd</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">lqnb</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qn</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">qd</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">ai_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `nt` zeros and values of the Airy function Ai and its derivative.</span>

<span class="sd">    Computes the first `nt` zeros, `a`, of the Airy function Ai(x);</span>
<span class="sd">    first `nt` zeros, `ap`, of the derivative of the Airy function Ai&#39;(x);</span>
<span class="sd">    the corresponding values Ai(a&#39;);</span>
<span class="sd">    and the corresponding values Ai&#39;(a).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        First `nt` zeros of Ai(x)</span>
<span class="sd">    ap : ndarray</span>
<span class="sd">        First `nt` zeros of Ai&#39;(x)</span>
<span class="sd">    ai : ndarray</span>
<span class="sd">        Values of Ai(x) evaluated at first `nt` zeros of Ai&#39;(x)</span>
<span class="sd">    aip : ndarray</span>
<span class="sd">        Values of Ai&#39;(x) evaluated at first `nt` zeros of Ai(x)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; a, ap, ai, aip = special.ai_zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([-2.33810741, -4.08794944, -5.52055983])</span>
<span class="sd">    &gt;&gt;&gt; ap</span>
<span class="sd">    array([-1.01879297, -3.24819758, -4.82009921])</span>
<span class="sd">    &gt;&gt;&gt; ai</span>
<span class="sd">    array([ 0.53565666, -0.41901548,  0.38040647])</span>
<span class="sd">    &gt;&gt;&gt; aip</span>
<span class="sd">    array([ 0.70121082, -0.80311137,  0.86520403])</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be a positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">airyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bi_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `nt` zeros and values of the Airy function Bi and its derivative.</span>

<span class="sd">    Computes the first `nt` zeros, b, of the Airy function Bi(x);</span>
<span class="sd">    first `nt` zeros, b&#39;, of the derivative of the Airy function Bi&#39;(x);</span>
<span class="sd">    the corresponding values Bi(b&#39;);</span>
<span class="sd">    and the corresponding values Bi&#39;(b).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : ndarray</span>
<span class="sd">        First `nt` zeros of Bi(x)</span>
<span class="sd">    bp : ndarray</span>
<span class="sd">        First `nt` zeros of Bi&#39;(x)</span>
<span class="sd">    bi : ndarray</span>
<span class="sd">        Values of Bi(x) evaluated at first `nt` zeros of Bi&#39;(x)</span>
<span class="sd">    bip : ndarray</span>
<span class="sd">        Values of Bi&#39;(x) evaluated at first `nt` zeros of Bi(x)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import special</span>
<span class="sd">    &gt;&gt;&gt; b, bp, bi, bip = special.bi_zeros(3)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([-1.17371322, -3.2710933 , -4.83073784])</span>
<span class="sd">    &gt;&gt;&gt; bp</span>
<span class="sd">    array([-2.29443968, -4.07315509, -5.51239573])</span>
<span class="sd">    &gt;&gt;&gt; bi</span>
<span class="sd">    array([-0.45494438,  0.39652284, -0.36796916])</span>
<span class="sd">    &gt;&gt;&gt; bip</span>
<span class="sd">    array([ 0.60195789, -0.76031014,  0.83699101])</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kf</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be a positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">airyzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">kf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">lmbda</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Jahnke-Emden Lambda function, Lambdav(x).</span>

<span class="sd">    This function is defined as [2]_,</span>

<span class="sd">    .. math:: \Lambda_v(x) = \Gamma(v+1) \frac{J_v(x)}{(x/2)^v},</span>

<span class="sd">    where :math:`\Gamma` is the gamma function and :math:`J_v` is the</span>
<span class="sd">    Bessel function of the first kind.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of the Lambda function</span>
<span class="sd">    x : float</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vl : ndarray</span>
<span class="sd">        Values of Lambda_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>
<span class="sd">    dl : ndarray</span>
<span class="sd">        Derivatives Lambda_vi&#39;(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>
<span class="sd">    .. [2] Jahnke, E. and Emde, F. &quot;Tables of Functions with Formulae and</span>
<span class="sd">           Curves&quot; (4th ed.), Dover, 1945</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;argument must be &gt; 0.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">n</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">v0</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
        <span class="n">vm</span><span class="p">,</span> <span class="n">vl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">lamv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vm</span><span class="p">,</span> <span class="n">vl</span><span class="p">,</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">lamn</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vl</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">dl</span><span class="p">[:(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">pbdv_seq</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parabolic cylinder functions Dv(x) and derivatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of the parabolic cylinder function</span>
<span class="sd">    x : float</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dv : ndarray</span>
<span class="sd">        Values of D_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>
<span class="sd">    dp : ndarray</span>
<span class="sd">        Derivatives D_vi&#39;(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 13.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">v</span><span class="o">-</span><span class="n">n</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">v0</span>
    <span class="n">dv</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdd</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">pbdv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dv</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">pbvv_seq</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parabolic cylinder functions Vv(x) and derivatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : float</span>
<span class="sd">        Order of the parabolic cylinder function</span>
<span class="sd">    x : float</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dv : ndarray</span>
<span class="sd">        Values of V_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>
<span class="sd">    dp : ndarray</span>
<span class="sd">        Derivatives V_vi&#39;(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 13.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">v</span><span class="o">-</span><span class="n">n</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">v0</span>
    <span class="n">dv</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">pdd</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">pbvv</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dv</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">pbdn_seq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parabolic cylinder functions Dn(z) and derivatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Order of the parabolic cylinder function</span>
<span class="sd">    z : complex</span>
<span class="sd">        Value at which to evaluate the function and derivatives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dv : ndarray</span>
<span class="sd">        Values of D_i(z), for i=0, ..., i=n.</span>
<span class="sd">    dp : ndarray</span>
<span class="sd">        Derivatives D_i&#39;(z), for i=0, ..., i=n.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996, chapter 13.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be an integer.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">cpb</span><span class="p">,</span> <span class="n">cpd</span> <span class="o">=</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">cpbdn</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cpb</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">cpd</span><span class="p">[:</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">ber_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function ber.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ber</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bei_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function bei.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bei</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ker_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function ker.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ker</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kei_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of the Kelvin function kei.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    kei</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">berp_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function ber.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the derivative of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ber, berp</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">beip_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function bei.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the derivative of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bei, beip</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kerp_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function ker.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the derivative of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ker, kerp</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">keip_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function kei.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of zeros to compute. Must be positive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        First `nt` zeros of the derivative of the Kelvin function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    kei, keip</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kelvin_zeros</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute nt zeros of all Kelvin functions.</span>

<span class="sd">    Returned in a length-8 tuple of arrays of length nt.  The tuple contains</span>
<span class="sd">    the arrays of zeros of (ber, bei, ker, kei, ber&#39;, bei&#39;, ker&#39;, kei&#39;).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nt must be positive integer scalar.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
            <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
            <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
            <span class="n">_specfun</span><span class="o">.</span><span class="n">klvnzo</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">pro_cv_seq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Characteristic values for prolate spheroidal wave functions.</span>

<span class="sd">    Compute a sequence of characteristic values for the prolate</span>
<span class="sd">    spheroidal wave functions for mode m and n&#39;=m..n and spheroidal</span>
<span class="sd">    parameter c.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Modes must be integers.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">199</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Difference between n and m is too large.&quot;</span><span class="p">)</span>
    <span class="n">maxL</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">segv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="n">maxL</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">obl_cv_seq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Characteristic values for oblate spheroidal wave functions.</span>

<span class="sd">    Compute a sequence of characteristic values for the oblate</span>
<span class="sd">    spheroidal wave functions for mode m and n&#39;=m..n and spheroidal</span>
<span class="sd">    parameter c.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special</span>
<span class="sd">           Functions&quot;, John Wiley and Sons, 1996.</span>
<span class="sd">           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments must be scalars.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">floor</span><span class="p">(</span><span class="n">m</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Modes must be integers.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">199</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Difference between n and m is too large.&quot;</span><span class="p">)</span>
    <span class="n">maxL</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">_specfun</span><span class="o">.</span><span class="n">segv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="n">maxL</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">comb</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The number of combinations of N things taken k at a time.</span>

<span class="sd">    This is often expressed as &quot;N choose k&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int, ndarray</span>
<span class="sd">        Number of things.</span>
<span class="sd">    k : int, ndarray</span>
<span class="sd">        Number of elements taken.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        For integers, if `exact` is False, then floating point precision is</span>
<span class="sd">        used, otherwise the result is computed exactly. For non-integers, if</span>
<span class="sd">        `exact` is True, the inputs are currently cast to integers, though</span>
<span class="sd">        this behavior is deprecated (see below).</span>
<span class="sd">    repetition : bool, optional</span>
<span class="sd">        If `repetition` is True, then the number of combinations with</span>
<span class="sd">        repetition is computed.</span>
<span class="sd">    legacy : bool, optional</span>
<span class="sd">        If `legacy` is True and `exact` is True, then non-integral arguments</span>
<span class="sd">        are cast to ints; if `legacy` is False, the result for non-integral</span>
<span class="sd">        arguments is unaffected by the value of `exact`.</span>

<span class="sd">        .. deprecated:: 1.9.0</span>
<span class="sd">            Non-integer arguments are currently being cast to integers when</span>
<span class="sd">            `exact=True`. This behaviour is deprecated and the default will</span>
<span class="sd">            change to avoid the cast in SciPy 1.11.0. To opt into the future</span>
<span class="sd">            behavior set `legacy=False`. If you want to keep the</span>
<span class="sd">            argument-casting but silence this warning, cast your inputs</span>
<span class="sd">            directly, e.g. ``comb(int(your_N), int(your_k), exact=True)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : int, float, ndarray</span>
<span class="sd">        The total number of combinations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    binom : Binomial coefficient considered as a function of two real</span>
<span class="sd">            variables.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Array arguments accepted only for exact=False case.</span>
<span class="sd">    - If N &lt; 0, or k &lt; 0, then 0 is returned.</span>
<span class="sd">    - If k &gt; N and repetition=False, then 0 is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import comb</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([3, 4])</span>
<span class="sd">    &gt;&gt;&gt; n = np.array([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; comb(n, k, exact=False)</span>
<span class="sd">    array([ 120.,  210.])</span>
<span class="sd">    &gt;&gt;&gt; comb(10, 3, exact=True)</span>
<span class="sd">    120</span>
<span class="sd">    &gt;&gt;&gt; comb(10, 3, exact=True, repetition=True)</span>
<span class="sd">    220</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">repetition</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">comb</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="n">legacy</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">legacy</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Non-integer arguments are currently being cast to &quot;</span>
                    <span class="s2">&quot;integers when exact=True. This behaviour is &quot;</span>
                    <span class="s2">&quot;deprecated and the default will change to avoid the cast &quot;</span>
                    <span class="s2">&quot;in SciPy 1.11.0. To opt into the future behavior set &quot;</span>
                    <span class="s2">&quot;legacy=False. If you want to keep the argument-casting &quot;</span>
                    <span class="s2">&quot;but silence this warning, cast your inputs directly, &quot;</span>
                    <span class="s2">&quot;e.g. comb(int(your_N), int(your_k), exact=True).&quot;</span><span class="p">,</span>
                    <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">comb</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="c1"># _comb_int casts inputs to integers</span>
        <span class="k">return</span> <span class="n">_comb_int</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">binom</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">cond</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>


<span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Permutations of N things taken k at a time, i.e., k-permutations of N.</span>

<span class="sd">    It&#39;s also known as &quot;partial permutations&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int, ndarray</span>
<span class="sd">        Number of things.</span>
<span class="sd">    k : int, ndarray</span>
<span class="sd">        Number of elements taken.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If `exact` is False, then floating point precision is used, otherwise</span>
<span class="sd">        exact long integer is computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : int, ndarray</span>
<span class="sd">        The number of k-permutations of N.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Array arguments accepted only for exact=False case.</span>
<span class="sd">    - If k &gt; N, N &lt; 0, or k &lt; 0, then a 0 is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import perm</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([3, 4])</span>
<span class="sd">    &gt;&gt;&gt; n = np.array([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; perm(n, k)</span>
<span class="sd">    array([  720.,  5040.])</span>
<span class="sd">    &gt;&gt;&gt; perm(10, 3, exact=True)</span>
<span class="sd">    720</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">poch</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">cond</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>


<span class="c1"># https://stackoverflow.com/a/16327037</span>
<span class="k">def</span> <span class="nf">_range_prod</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Product of a range of numbers.</span>

<span class="sd">    Returns the product of</span>
<span class="sd">    lo * (lo+1) * (lo+2) * ... * (hi-2) * (hi-1) * hi</span>
<span class="sd">    = hi! / (lo-1)!</span>

<span class="sd">    Breaks into smaller products first for speed:</span>
<span class="sd">    _range_prod(2, 9) = ((2*3)*(4*5))*((6*7)*(8*9))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi</span> <span class="o">+</span> <span class="n">lo</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">_range_prod</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">*</span> <span class="n">_range_prod</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lo</span> <span class="o">==</span> <span class="n">hi</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lo</span>
    <span class="k">return</span> <span class="n">lo</span> <span class="o">*</span> <span class="n">hi</span>


<div class="viewcode-block" id="factorial"><a class="viewcode-back" href="../../../api.html#stingray.deadtime.model.factorial">[docs]</a><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The factorial of a number or array of numbers.</span>

<span class="sd">    The factorial of non-negative integer `n` is the product of all</span>
<span class="sd">    positive integers less than or equal to `n`::</span>

<span class="sd">        n! = n * (n - 1) * (n - 2) * ... * 1</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int or array_like of ints</span>
<span class="sd">        Input values.  If ``n &lt; 0``, the return value is 0.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If True, calculate the answer exactly using long integer arithmetic.</span>
<span class="sd">        If False, result is approximated in floating point rapidly using the</span>
<span class="sd">        `gamma` function.</span>
<span class="sd">        Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nf : float or int or ndarray</span>
<span class="sd">        Factorial of `n`, as integer or float depending on `exact`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For arrays with ``exact=True``, the factorial is computed only once, for</span>
<span class="sd">    the largest input, with each other result computed in the process.</span>
<span class="sd">    The output dtype is increased to ``int64`` or ``object`` if necessary.</span>

<span class="sd">    With ``exact=False`` the factorial is approximated using the gamma</span>
<span class="sd">    function:</span>

<span class="sd">    .. math:: n! = \\Gamma(n+1)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import factorial</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array([3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; factorial(arr, exact=False)</span>
<span class="sd">    array([   6.,   24.,  120.])</span>
<span class="sd">    &gt;&gt;&gt; factorial(arr, exact=True)</span>
<span class="sd">    array([  6,  24, 120])</span>
<span class="sd">    &gt;&gt;&gt; factorial(5, exact=True)</span>
<span class="sd">    120</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">n</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">un</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

            <span class="c1"># Convert to object array of long ints if np.int_ can&#39;t handle size</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span>
            <span class="k">elif</span> <span class="n">un</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="nb">object</span>
            <span class="k">elif</span> <span class="n">un</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

            <span class="c1"># Handle invalid/trivial values</span>
            <span class="c1"># Ignore runtime warning when less operator used w/np.nan</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">un</span> <span class="o">=</span> <span class="n">un</span><span class="p">[</span><span class="n">un</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Calculate products of each range of numbers</span>
            <span class="k">if</span> <span class="n">un</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">un</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">==</span> <span class="n">un</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">un</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="n">un</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">un</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">val</span> <span class="o">*=</span> <span class="n">_range_prod</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">n</span> <span class="o">==</span> <span class="n">current</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">_factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<span class="k">def</span> <span class="nf">factorial2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Double factorial.</span>

<span class="sd">    This is the factorial with every second value skipped.  E.g., ``7!! = 7 * 5</span>
<span class="sd">    * 3 * 1``.  It can be approximated numerically as::</span>

<span class="sd">      n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd</span>
<span class="sd">          = 2**(n/2) * (n/2)!                           n even</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int or array_like</span>
<span class="sd">        Calculate ``n!!``.  Arrays are only supported with `exact` set</span>
<span class="sd">        to False. If ``n &lt; -1``, the return value is 0.</span>
<span class="sd">        Otherwise if ``n &lt;= 0``, the return value is 1.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        The result can be approximated rapidly using the gamma-formula</span>
<span class="sd">        above (default).  If `exact` is set to True, calculate the</span>
<span class="sd">        answer exactly using integer arithmetic.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nff : float or int</span>
<span class="sd">        Double factorial of `n`, as an int or a float depending on</span>
<span class="sd">        `exact`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import factorial2</span>
<span class="sd">    &gt;&gt;&gt; factorial2(7, exact=False)</span>
<span class="sd">    array(105.00000000000001)</span>
<span class="sd">    &gt;&gt;&gt; factorial2(7, exact=True)</span>
<span class="sd">    105</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">*=</span> <span class="n">k</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">oddn</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">cond1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">evenn</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">cond2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">nd2o</span> <span class="o">=</span> <span class="n">oddn</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">nd2e</span> <span class="o">=</span> <span class="n">evenn</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">place</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">cond1</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nd2o</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">nd2o</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="n">place</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nd2e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">nd2e</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">vals</span>


<span class="k">def</span> <span class="nf">factorialk</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Multifactorial of n of order k, n(!!...!).</span>

<span class="sd">    This is the multifactorial of n skipping k values.  For example,</span>

<span class="sd">      factorialk(17, 4) = 17!!!! = 17 * 13 * 9 * 5 * 1</span>

<span class="sd">    In particular, for any integer ``n``, we have</span>

<span class="sd">      factorialk(n, 1) = factorial(n)</span>

<span class="sd">      factorialk(n, 2) = factorial2(n)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Calculate multifactorial. If ``n &lt; 1 - k``, the return value is 0.</span>
<span class="sd">        Otherwise if ``n &lt;= 0``, the return value is 1.</span>
<span class="sd">    k : int</span>
<span class="sd">        Order of multifactorial.</span>
<span class="sd">    exact : bool, optional</span>
<span class="sd">        If exact is set to True, calculate the answer exactly using</span>
<span class="sd">        integer arithmetic.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : int</span>
<span class="sd">        Multifactorial of `n`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        Raises when exact is False</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import factorialk</span>
<span class="sd">    &gt;&gt;&gt; factorialk(5, 1, exact=True)</span>
<span class="sd">    120</span>
<span class="sd">    &gt;&gt;&gt; factorialk(5, 3, exact=True)</span>
<span class="sd">    10</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">-</span><span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">*</span><span class="n">j</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<span class="k">def</span> <span class="nf">zeta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Riemann or Hurwitz zeta function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like of float</span>
<span class="sd">        Input data, must be real</span>
<span class="sd">    q : array_like of float, optional</span>
<span class="sd">        Input data, must be real.  Defaults to Riemann zeta.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Output array for the computed values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array_like</span>
<span class="sd">        Values of zeta(x).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The two-argument version is the Hurwitz zeta function</span>

<span class="sd">    .. math::</span>

<span class="sd">        \zeta(x, q) = \sum_{k=0}^{\infty} \frac{1}{(k + q)^x};</span>

<span class="sd">    see [dlmf]_ for details. The Riemann zeta function corresponds to</span>
<span class="sd">    the case when ``q = 1``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    zetac</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [dlmf] NIST, Digital Library of Mathematical Functions,</span>
<span class="sd">        https://dlmf.nist.gov/25.11#i</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.special import zeta, polygamma, factorial</span>

<span class="sd">    Some specific values:</span>

<span class="sd">    &gt;&gt;&gt; zeta(2), np.pi**2/6</span>
<span class="sd">    (1.6449340668482266, 1.6449340668482264)</span>

<span class="sd">    &gt;&gt;&gt; zeta(4), np.pi**4/90</span>
<span class="sd">    (1.0823232337111381, 1.082323233711138)</span>

<span class="sd">    Relation to the `polygamma` function:</span>

<span class="sd">    &gt;&gt;&gt; m = 3</span>
<span class="sd">    &gt;&gt;&gt; x = 1.25</span>
<span class="sd">    &gt;&gt;&gt; polygamma(m, x)</span>
<span class="sd">    array(2.782144009188397)</span>
<span class="sd">    &gt;&gt;&gt; (-1)**(m+1) * factorial(m) * zeta(m+1, x)</span>
<span class="sd">    2.7821440091883969</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">_riemann_zeta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_ufuncs</span><span class="o">.</span><span class="n">_zeta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, Stingray Developers.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.0.0. &nbsp;
    Last built 04 May 2023. <br/>
  </p>
</footer>
  </body>
</html>